{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Protonic","text":"<p>This site contains a civil engineer's ongoing attempt to understand (some of) the physics behind proton therapy - having undergone said therapy!</p>"},{"location":"BasicTheory/","title":"The general idea of proton therapy","text":"In\u00a0[2]: Copied! <pre># Constants\nmp = 1.67262e-27 # rest mass of proton [kg-1]\nc = 299792458 # speed of light [ms^-1]\n\n# Rest energy of proton\nJoule2MeV = lambda J: J/1.602176634e-13 # conversion from Joule to MeV\n\nE0 = mp*c**2  # in kgms^-2 === Joule\n\n# Convert to MeV\nE0 = Joule2MeV(E0)\n\n# Variables\nEk = 250 # MeV\n\n# Functions\nbeta = lambda Ek:  (1-(Ek/E0 + 1)**-2)**0.5\n\n# given an energy beam of 250 MeV, the total energy is \nEt = (Ek**2 + E0**2)**0.5\n\n# Velocity of a proton\nb = beta(Ek)\nv = b*c\n\n# Answer\nprint(f\"The velocity of particles in a {Ek} MeV proton beam is {v/1000:.0f} km/s, or {b*100:.5} % the speed of light\")\n</pre> # Constants mp = 1.67262e-27 # rest mass of proton [kg-1] c = 299792458 # speed of light [ms^-1]  # Rest energy of proton Joule2MeV = lambda J: J/1.602176634e-13 # conversion from Joule to MeV  E0 = mp*c**2  # in kgms^-2 === Joule  # Convert to MeV E0 = Joule2MeV(E0)  # Variables Ek = 250 # MeV  # Functions beta = lambda Ek:  (1-(Ek/E0 + 1)**-2)**0.5  # given an energy beam of 250 MeV, the total energy is  Et = (Ek**2 + E0**2)**0.5  # Velocity of a proton b = beta(Ek) v = b*c  # Answer print(f\"The velocity of particles in a {Ek} MeV proton beam is {v/1000:.0f} km/s, or {b*100:.5} % the speed of light\")   <pre>The velocity of particles in a 250 MeV proton beam is 183955 km/s, or 61.361 % the speed of light\n</pre> In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\nfrom matplotlib import ticker\nimport numpy as np \n\nplt.rcParams['font.family'] = 'serif'\nfig, ax = plt.subplots(1, figsize=(10,5))\n\ne = np.logspace(-2, 7)\n\nax.plot(e, beta(e), '-k')\nax.axhline(1, color='red', label='c')\n\nax.fill_betweenx([0, 1], 100, 250, \n                 hatch=\"//\",\n                 edgecolor='m', \n                 facecolor=\"white\", \n                 label=\"Initial Proton therapy energy range\")\n\nax.fill_betweenx([0, 1], 1e6, 7e6, \n                 hatch=\"//\",\n                 edgecolor='k', \n                 facecolor=\"white\", \n                 label=\"LHC experimental range\")\n\nax.set_xscale('log')\nax.set_xlabel('Kinetic energy [MeV]')\nax.set_ylabel('\u03b2 [v/c]')\n\nx_major = ticker.LogLocator(base = 10) \nx_minor = ticker.LogLocator(base = 10, subs =[1.1, 1.2, 1.3]) \n  \nax.xaxis.set_major_locator(x_major) \nax.xaxis.set_minor_locator(x_minor)\n\n\nax.spines['left'].set_bounds(0, 1)\nax.spines['bottom'].set_bounds(e[0], e[-1])\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\n\nax.legend()\n</pre> import matplotlib.pyplot as plt from matplotlib import ticker import numpy as np   plt.rcParams['font.family'] = 'serif' fig, ax = plt.subplots(1, figsize=(10,5))  e = np.logspace(-2, 7)  ax.plot(e, beta(e), '-k') ax.axhline(1, color='red', label='c')  ax.fill_betweenx([0, 1], 100, 250,                   hatch=\"//\",                  edgecolor='m',                   facecolor=\"white\",                   label=\"Initial Proton therapy energy range\")  ax.fill_betweenx([0, 1], 1e6, 7e6,                   hatch=\"//\",                  edgecolor='k',                   facecolor=\"white\",                   label=\"LHC experimental range\")  ax.set_xscale('log') ax.set_xlabel('Kinetic energy [MeV]') ax.set_ylabel('\u03b2 [v/c]')  x_major = ticker.LogLocator(base = 10)  x_minor = ticker.LogLocator(base = 10, subs =[1.1, 1.2, 1.3])     ax.xaxis.set_major_locator(x_major)  ax.xaxis.set_minor_locator(x_minor)   ax.spines['left'].set_bounds(0, 1) ax.spines['bottom'].set_bounds(e[0], e[-1]) ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False)   ax.legend() Out[3]: <pre>&lt;matplotlib.legend.Legend at 0x107ae6390&gt;</pre>"},{"location":"BasicTheory/#the-general-idea-of-proton-therapy","title":"The general idea of proton therapy\u00b6","text":"<p>Proton therapy delivers a targeted radiation dose on a tumor that will damage the DNA of cells, harm reproduction and eventuall kill the cells. In this notebook, we'll look at the physics behind this therapy, just for the fun of it.</p> <p>The first difficult word is dose. Dose is a quantity which is the measure of the energy deposited in matter by ionizing radiation per unit mass. The location and quantity of the dose depends on the energy of a proton.</p>"},{"location":"BasicTheory/#how-much-energy-does-a-proton-have","title":"How much energy does a proton have?\u00b6","text":"<p>The energy of a moving proton is a combination of its rest mass and kinetic energy. Because the velocity of a proton is close to the speed of light, relativistic effects cannot be ignored. The total mass $E_T$ of a proton is given by the energy-momentum relation:</p> <p>$$ E_T^2 = E_0^2 + E_k^2  $$</p> <p>with rest energy $E_0 = m_0c^2$, rest mass $m_0$ is the rest mass, and kinetic energy $E_k=pc$. The typical kinetic energy of protons in radiation therapy is 100 to 250 MeV (Note: However, a treatment system that can produce 250 MeV protons must provide adequate neutron shielding for neutrons produced by interactions of a beam of this energy in the treatment head and in a patient., Sengbush et al.).</p> <p>The relativistic expression for linear momentum $p$ is</p> <p>$$ p = m_0\\gamma v $$ with Lorentz factor $\\gamma$ defined is $$ \\gamma=\\sqrt{1-\\beta}^{-1} $$ where $\\beta=v/c$ - the ratio of particle velocity $v$ and the speed of light $c$. Rearranging a bit and substituting the definitions for $E_0 = m_0c^2$ and $E_k=pc$ gives a tidy formulation: $$ E_k = (\\gamma-1)E_0 $$</p> <p>As function of beta this reads:</p> <p>$$ \\beta = \\sqrt{1-\\left(\\frac{E_k}{E_0} + 1\\right)^{-2}} $$</p> <p>The velocity is then computed as $v = \\beta c$:</p>"},{"location":"BasicTheory/#proton-therapy-vs-the-lhc","title":"Proton therapy vs the LHC\u00b6","text":"<p>While the protons in therapy are (initially) going at relativistic speeds, it's nowhere close to the LHC collider. For the fun of it, let's plot how the energy ranges of proton therapy (100-250 MeV) compare to e.g. the LHC collider (1-7 TeV).</p>"},{"location":"StoppingPower/","title":"Energy loss of protons traversing a medium","text":"In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt \nimport numpy as np \nfrom scipy.optimize import minimize\nfrom matplotlib import ticker\n\n# Gobal options.\nplt.rcParams['font.family'] = 'serif'\n# bragg differential, which should give the 'bragg curve\" (?)\ndEdx_bragg = lambda Ei, a, p: Ei**(1-p)/(a*p)  # note it this is negative stopping power!\nrange_bragg = lambda Ei, a, p: a*Ei**p\n\n# Parse data\ndef PSTAR(material=\"H\"):\n    with open(f\"../data/pstar{material}.dat\", \"r\") as f:\n        lines = [line.strip() for line in f]\n        data = np.loadtxt(lines, delimiter=' ', skiprows=8)\n    return data\n    \n# Fit bragg function to data \n# Note: after visual inspection, the function seems to model\n# the curve for energies above 0.125 MeV, not below. \ndata = PSTAR(\"H\")\ndatamask = data.T[0]&gt; 0.125\nerror_func = lambda x: abs(sum(dEdx_bragg(data.T[0, datamask], x[0]*0.001, x[1]) - data.T[3, datamask]))\nx0 =  [1.12,1.77]  # initial guess\nres = minimize(error_func,x0)\n\n# Print the result of the fit\nprint(f\"Fitted parameters for Hydrogen: a={res.x[0]*0.001:0.5f}, p = {res.x[1]:.2f}\")\n</pre> import matplotlib.pyplot as plt  import numpy as np  from scipy.optimize import minimize from matplotlib import ticker  # Gobal options. plt.rcParams['font.family'] = 'serif' # bragg differential, which should give the 'bragg curve\" (?) dEdx_bragg = lambda Ei, a, p: Ei**(1-p)/(a*p)  # note it this is negative stopping power! range_bragg = lambda Ei, a, p: a*Ei**p  # Parse data def PSTAR(material=\"H\"):     with open(f\"../data/pstar{material}.dat\", \"r\") as f:         lines = [line.strip() for line in f]         data = np.loadtxt(lines, delimiter=' ', skiprows=8)     return data      # Fit bragg function to data  # Note: after visual inspection, the function seems to model # the curve for energies above 0.125 MeV, not below.  data = PSTAR(\"H\") datamask = data.T[0]&gt; 0.125 error_func = lambda x: abs(sum(dEdx_bragg(data.T[0, datamask], x[0]*0.001, x[1]) - data.T[3, datamask])) x0 =  [1.12,1.77]  # initial guess res = minimize(error_func,x0)  # Print the result of the fit print(f\"Fitted parameters for Hydrogen: a={res.x[0]*0.001:0.5f}, p = {res.x[1]:.2f}\")  <pre>Fitted parameters for Hydrogen: a=0.00083, p = 1.78\n</pre> <p>Let's plot the result of our fit. Note that we fit only on the range above 0.125 MeV.</p> In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, figsize=(10,5))\n\nax.plot(data.T[0], data.T[3], '.k', label=\"Total Stopping power (PSTAR)\")\nax.plot(data.T[0, datamask], dEdx_bragg(data.T[0, datamask],  res.x[0]*0.001,res.x[1]), '-', color='r', label='Bragg fit')\nax.set_ylim([0, 1.1*max(data.T[3])])\n\n# Plot proton therapy application range\nax.fill_betweenx([0, 1.1*max(data.T[3])], 100, 250, \n                 hatch=\"//\",\n                 edgecolor='k', \n                 facecolor=\"white\", \n                 label=\"Proton therapy energy range\")\n\n# plot range on a secondary axis\n\nax2 = ax.twinx()\nax2.plot(data.T[0], data.T[4], '.r', label=\"CSDA Range (PSTAR)\")\nax2.plot(data.T[0, datamask], range_bragg(data.T[0, datamask], res.x[0]*0.001,res.x[1]), color='k', label=\"Bragg fit\")\n\n# Set plot scale &amp; labels\n# Remove axis lines.\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.spines['left'].set_visible(False)\n\nax.set_xscale('log')\nax2.set_yscale('log')\nax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\nax2.yaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\n\n\nax.set_xlabel('Initial Kinetic Energy [MeV]')\nax.set_ylabel('Stopping power [MeV cm2/g]')\nax2.set_ylabel('Range [g/cm]')\n\n# Title.\nax.text(500, 200, \"Stopping power of\\n a proton\\nin hydrogen (PSTAR)\", size=11)\n\nax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.05),\n          ncol=3, fancybox=True, shadow=True)\nax2.legend(loc='lower center', bbox_to_anchor=(0.5, 1.05),\n          ncol=3, fancybox=True, shadow=True)\n</pre> fig, ax = plt.subplots(1, figsize=(10,5))  ax.plot(data.T[0], data.T[3], '.k', label=\"Total Stopping power (PSTAR)\") ax.plot(data.T[0, datamask], dEdx_bragg(data.T[0, datamask],  res.x[0]*0.001,res.x[1]), '-', color='r', label='Bragg fit') ax.set_ylim([0, 1.1*max(data.T[3])])  # Plot proton therapy application range ax.fill_betweenx([0, 1.1*max(data.T[3])], 100, 250,                   hatch=\"//\",                  edgecolor='k',                   facecolor=\"white\",                   label=\"Proton therapy energy range\")  # plot range on a secondary axis  ax2 = ax.twinx() ax2.plot(data.T[0], data.T[4], '.r', label=\"CSDA Range (PSTAR)\") ax2.plot(data.T[0, datamask], range_bragg(data.T[0, datamask], res.x[0]*0.001,res.x[1]), color='k', label=\"Bragg fit\")  # Set plot scale &amp; labels # Remove axis lines. ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax2.spines['top'].set_visible(False) ax2.spines['left'].set_visible(False)  ax.set_xscale('log') ax2.set_yscale('log') ax.yaxis.set_minor_locator(ticker.AutoMinorLocator()) ax2.yaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))   ax.set_xlabel('Initial Kinetic Energy [MeV]') ax.set_ylabel('Stopping power [MeV cm2/g]') ax2.set_ylabel('Range [g/cm]')  # Title. ax.text(500, 200, \"Stopping power of\\n a proton\\nin hydrogen (PSTAR)\", size=11)  ax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.05),           ncol=3, fancybox=True, shadow=True) ax2.legend(loc='lower center', bbox_to_anchor=(0.5, 1.05),           ncol=3, fancybox=True, shadow=True)   Out[7]: <pre>&lt;matplotlib.legend.Legend at 0x10c54b770&gt;</pre>"},{"location":"StoppingPower/#energy-loss-of-protons-traversing-a-medium","title":"Energy loss of protons traversing a medium\u00b6","text":""},{"location":"StoppingPower/#how-protons-deliver-dose","title":"How protons deliver dose\u00b6","text":"<p>Protons deliver dose by interacting with matter. There are four mechanisms:</p> <ol> <li>Inelastic coulomb interaction with electrons: positively charged protons passing through matter are dragged by negatively charged electrons. This creates 'friction', which leads to energy loss of the proton and ionisation of the matter.  These interactions are described by the \"Vavilov energy straggling distribution\".</li> <li>Elastic coulomb collission with nuclei: protons passing close to an atomic nucleus are repulsed by electrons and change course. This scattering is described by a Moliere distribution.</li> <li>Inelastic nuclear reactions: when a proton collides with a nucleus and secondary particles are emitted. This energy loss is an empirical formula based on experimental data [PTRAN].</li> <li>Bremstrahlung: the release of a photon when a proton loses kinetic energy. This is typically ignored in proton therapy, since this only play a role in very high energy protons.</li> </ol> <p>However, most sources mention that only the first is relevant to compute the stopping power of a proton during radiation therapy.</p>"},{"location":"StoppingPower/#energy-loss-rate-of-ions-linear-stopping-power","title":"Energy loss rate of ions (linear stopping power)\u00b6","text":"<p>The energy loss or linear stopping power for a beam of protons (not a single particle and regardless of the mechanism involved) is defined as reduction of beam Energy (E) over distance (x):</p> <p>$$ S = -\\frac{dE}{dx} $$</p>"},{"location":"StoppingPower/#bragg-kleeman-approximation","title":"Bragg-Kleeman approximation\u00b6","text":"<p>The Bragg-Kleeman (1905) rule is an empirical fit that approximates the solution for dE/dX based on parameters $\\alpha$ and $x$</p> <p>$$ -\\frac{dE}{\\rho dx} \\approx -\\frac{E_i^{1-p}}{\\rho \\alpha p} $$</p> <p>Note that here the stopping power is divided over the material density $\\rho$. This is also how the PSTAR data is presented. with range</p> <p>$$ R \\rho^{-1} = \\rho^{-1} \\alpha E_i^p $$</p> <p>with $\\alpha$ a material-dependent constant, $p$ a constant that takes into account the dependence on the energy of the beam and $E_i$ the initial energy of the proton beam. The constants $\\alpha$ and $p$ must be fitted or obtained from data, e.g. the PSTAR dataset.</p>"},{"location":"bethe/","title":"Formula","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np \nimport matplotlib.pyplot as plt\nimport protonic  \nimport constants as const\n\n# A proton traversing hydrogen gass\ndata = protonic.PSTAR(\"H\")\np = protonic.projectiles.get('proton')\n\n# Functions\n# note, this formula is also available in protonic as bethebloch\nbeta = lambda Ek:  (1-(Ek/p.E0 + 1)**-2)**0.5\ngamma = lambda Ek:  (1-beta(Ek)**2)**-0.5\nK = 4*np.pi*const.Na*const.re**2*const.mec2  # MeV cm2 / g\nbethe = lambda Ek, material, projectile: K * projectile.z**2 * material.Z / material.A * 1 / beta(Ek)**2 * (np.log(2*const.mec2*beta(Ek)**2/(material.I*(1-beta(Ek)**2))) - beta(Ek)**2)\n\n# Plotting\nfig, ax = plt.subplots(1, figsize=(10,5))\n\n# Plot data\nax.plot(data.T[0], data.T[3], '.k', label=\"Total Stopping power (PSTAR, H)\")\n\n# Plot proton therapy application range\nax.fill_betweenx([0, 1.1*max(data.T[3])], 100, 250, \n                 hatch=\"//\",\n                 edgecolor='k', \n                 facecolor=\"white\", \n                 label=\"Initial proton therapy energy range\")\n\n# Plot Bethe-Bloch formula\nx = np.logspace(-3, 4)\nax.plot(x, bethe(x, \n                protonic.elements.get(\"H\"), \n                protonic.projectiles.get('proton')), '-', color='r', label='Bethe-Bloch (H)')\n\n# set labels and log scales\nax.set_xscale('log')\nax.set_yscale('log')\nax.set_xlabel('Initial Kinetic Energy [MeV]')\nax.set_ylabel('Stopping power [MeV cm2/g]')\nax.grid(visible=True, which='major', color='k')\nax.grid(visible=True, which='minor', color=[0.9]*3)\nax.legend(facecolor='w', framealpha=1, shadow=True)\n</pre> import numpy as np  import matplotlib.pyplot as plt import protonic   import constants as const  # A proton traversing hydrogen gass data = protonic.PSTAR(\"H\") p = protonic.projectiles.get('proton')  # Functions # note, this formula is also available in protonic as bethebloch beta = lambda Ek:  (1-(Ek/p.E0 + 1)**-2)**0.5 gamma = lambda Ek:  (1-beta(Ek)**2)**-0.5 K = 4*np.pi*const.Na*const.re**2*const.mec2  # MeV cm2 / g bethe = lambda Ek, material, projectile: K * projectile.z**2 * material.Z / material.A * 1 / beta(Ek)**2 * (np.log(2*const.mec2*beta(Ek)**2/(material.I*(1-beta(Ek)**2))) - beta(Ek)**2)  # Plotting fig, ax = plt.subplots(1, figsize=(10,5))  # Plot data ax.plot(data.T[0], data.T[3], '.k', label=\"Total Stopping power (PSTAR, H)\")  # Plot proton therapy application range ax.fill_betweenx([0, 1.1*max(data.T[3])], 100, 250,                   hatch=\"//\",                  edgecolor='k',                   facecolor=\"white\",                   label=\"Initial proton therapy energy range\")  # Plot Bethe-Bloch formula x = np.logspace(-3, 4) ax.plot(x, bethe(x,                  protonic.elements.get(\"H\"),                  protonic.projectiles.get('proton')), '-', color='r', label='Bethe-Bloch (H)')  # set labels and log scales ax.set_xscale('log') ax.set_yscale('log') ax.set_xlabel('Initial Kinetic Energy [MeV]') ax.set_ylabel('Stopping power [MeV cm2/g]') ax.grid(visible=True, which='major', color='k') ax.grid(visible=True, which='minor', color=[0.9]*3) ax.legend(facecolor='w', framealpha=1, shadow=True)  Out[\u00a0]: <pre>&lt;matplotlib.legend.Legend at 0x109e36db0&gt;</pre> <p>We see that the formula works fine for higher energy ranges but fails at lower (&lt;1 MeV) energy ranges. This is not surprising as the original formula was developed for high energy particles through gasses.</p> <p>As the proton travels through the medium, it will eventually reach those lower energy levels so we do need to account for it.</p> In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots(1, figsize=(10, 7))\n\nbetagamma = lambda x: beta(x)*gamma(x)\n\n# Plot proton therapy application range\nax.fill_betweenx([0, 1.1*max(data.T[3])], betagamma(100), betagamma(250), \n                 hatch=\"//\",\n                 edgecolor='k', \n                 facecolor=\"white\", \n                 label=\"Proton therapy energy range\")\n\nx = np.logspace(-1, 5)\nfor m in elements:\n    ax.plot(betagamma(x), bethe(x, elements.get(m)), '-k')\n    ax.text(betagamma(x)[-1], bethe(x, elements.get(m))[-1], m, backgroundcolor='w')\n\nax.set_ylabel(\"S [MeV cm^2 / g ]\")\nax.set_xscale('log')\nax.set_yscale('log')\nax.grid(visible=True, which='major', color='k')\nax.grid(visible=True, which='minor', color=[0.9]*3)\nax.set_xlabel('\u03b2\u03b3')\nax.set_ylabel('Stopping power [MeV cm2/g]')\nax.set_xlim(0.1, 1e2)\nax.set_ylim(1, 10)\n\nax.legend()\n</pre> fig, ax = plt.subplots(1, figsize=(10, 7))  betagamma = lambda x: beta(x)*gamma(x)  # Plot proton therapy application range ax.fill_betweenx([0, 1.1*max(data.T[3])], betagamma(100), betagamma(250),                   hatch=\"//\",                  edgecolor='k',                   facecolor=\"white\",                   label=\"Proton therapy energy range\")  x = np.logspace(-1, 5) for m in elements:     ax.plot(betagamma(x), bethe(x, elements.get(m)), '-k')     ax.text(betagamma(x)[-1], bethe(x, elements.get(m))[-1], m, backgroundcolor='w')  ax.set_ylabel(\"S [MeV cm^2 / g ]\") ax.set_xscale('log') ax.set_yscale('log') ax.grid(visible=True, which='major', color='k') ax.grid(visible=True, which='minor', color=[0.9]*3) ax.set_xlabel('\u03b2\u03b3') ax.set_ylabel('Stopping power [MeV cm2/g]') ax.set_xlim(0.1, 1e2) ax.set_ylim(1, 10)  ax.legend()  Out[6]: <pre>&lt;matplotlib.legend.Legend at 0x1186d2270&gt;</pre>"},{"location":"bethe/#bethe-bloch-approximation","title":"Bethe-Bloch approximation\u00b6","text":"<p>A (physically) more complete approximation is the so-called Bethe &amp; Bloch formula:</p> <p>$$ \\frac{S}{\\rho} = 4\\pi N_A r^2_em_ec^2\\frac{Z}{A}\\frac{z^2}{\\beta^2}\\left[\\ln \\frac{2m_ec^2\\gamma^2\\beta^2}{I}-\\beta^2\\right] $$</p> <p>with $\\rho$ the mass density of the material, and $N_A$ is Avogadro's number [mol<sup>-1</sup>], $r_e$ is the classical electron radius [m], $m_e$ is the mass of an electron [MeV], $z$ is the charge of the projectile [-], $Z$ is the atomic number of the absorbing material [-], $c$ is speed of light [m/s], $\\beta = v/c$ with $v$ the velocity of the projectile [m/s], Lorentz factor $\\gamma = (1- \\beta^2)^{-1/2}$ and $I$ is the mean excitation energy of the absorbing material [MeV].</p> <p>$A$ is described as the 'atomic mass' and 'mass number'. Note that this formula can only be dimensionally correct if $A$ has the dimension of [g mol$^{-1}$] and given the value of 1 (source).</p> <p>We can simplify this formula a bit by lumping most constants into a single one:</p> <p>$$ \\frac{S}{\\rho} = K \\frac{Z}{A} \\frac{z^2}{\\beta^2}\\left[\\ln \\frac{2m_ec^2\\gamma^2\\beta^2}{I}-\\beta^2\\right] $$</p> <p>with</p> <p>$$ K = 4\\pi N_A r^2_em_ec^2 $$</p> <p>K resolves to 0.307 MeV cm<sup>2</sup>/g. Note that K is the only term with a dimension in this formula. All other terms are dimensionless, so the unit of K is the unit of S over $\\rho$.</p> <p>We will see that the above formula works quite well in the ranges of the initial energy of the proton. However, as the proton travels through the medium (body), it loses energy and the formula fails:</p>"},{"location":"bethe/#corrections-for-low-energy","title":"Corrections for low-energy\u00b6","text":"<p>$$ \\frac{S}{\\rho} = 4\\pi N_A r^2_em_ec^2\\frac{Z}{A}\\frac{z^2}{\\beta^2}\\left[\\ln \\frac{2m_ec^2\\gamma^2\\beta^2}{I}-\\beta^2-\\frac{\\delta}{2}-\\frac{C}{Z}\\right] $$</p> <p>$\\delta$ is the density correction item arising from the shielding of remote electrons by close electrons and will result in a reduction of energy loss for higher energies, and $C$ is the shell correction item, which is important only for low energies where the particle velocity is near the velocity of the atomic electrons.\"</p> <p>The shell correction term C is important for us. From Salvat (2020): \"Salvat et al. [8] have determined the shell correction for neutral atoms of the elements with Z = 1\u201399 and projectile protons with energies up to 10<sup>10</sup> eV by using the GOSs calculated by means of the DHFS model.</p>"},{"location":"bragg_additivity/","title":"Bragg Additivity rule","text":"In\u00a0[4]: Copied! <pre>from protonic import bethebloch, PSTAR, compounds, projectiles\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\ndata = PSTAR(\"H2Oliquid\")\n\nfig, ax = plt.subplots(1, figsize=(10,5))\n\nax.plot(data.T[0], data.T[3], '.k', label=\"Total Stopping power (PSTAR)\")\n\n# Plot proton therapy application range\nax.fill_betweenx([0, 1.1*max(data.T[3])], 100, 250, \n                 hatch=\"//\",\n                 edgecolor='k', \n                 facecolor=\"white\", \n                 label=\"Proton therapy energy range\")\n\nx = np.logspace(-1, 4)\nax.plot(x, bethebloch(x, compounds.get(\"H2O\"), projectiles.get(\"proton\")), '-', color='r', label='Bethe-Bloch (H2O)')\n\nax.set_ylabel(\"S [MeV cm^2 / g ]\")\nax.set_xscale('log')\nax.set_yscale('log')\n\nax.set_xlabel('Initial Kinetic Energy [MeV]')\nax.set_ylabel('Stopping power [MeV cm2/g]')\n\nax.grid(visible=True, which='major', color='k')\nax.grid(visible=True, which='minor', color=[0.9]*3)\n\n\nax.legend(facecolor='w', framealpha=1, shadow=True)\n</pre> from protonic import bethebloch, PSTAR, compounds, projectiles from matplotlib import pyplot as plt import numpy as np  data = PSTAR(\"H2Oliquid\")  fig, ax = plt.subplots(1, figsize=(10,5))  ax.plot(data.T[0], data.T[3], '.k', label=\"Total Stopping power (PSTAR)\")  # Plot proton therapy application range ax.fill_betweenx([0, 1.1*max(data.T[3])], 100, 250,                   hatch=\"//\",                  edgecolor='k',                   facecolor=\"white\",                   label=\"Proton therapy energy range\")  x = np.logspace(-1, 4) ax.plot(x, bethebloch(x, compounds.get(\"H2O\"), projectiles.get(\"proton\")), '-', color='r', label='Bethe-Bloch (H2O)')  ax.set_ylabel(\"S [MeV cm^2 / g ]\") ax.set_xscale('log') ax.set_yscale('log')  ax.set_xlabel('Initial Kinetic Energy [MeV]') ax.set_ylabel('Stopping power [MeV cm2/g]')  ax.grid(visible=True, which='major', color='k') ax.grid(visible=True, which='minor', color=[0.9]*3)   ax.legend(facecolor='w', framealpha=1, shadow=True)  Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x10f41c440&gt;</pre>"},{"location":"bragg_additivity/#stopping-power-in-compounds","title":"Stopping power in compounds\u00b6","text":"<p>The Bethe Bloch formula can be used on compounds using the Bragg Additivity Rule. This rule assumes that a compound can be approximated as  layers of the constituent elements. In that case:</p> <p>$$ S = \\Sigma w_j S $$</p> <p>with $w_j$ the fraction by weight of the jth element.</p>"},{"location":"bragg_peak/","title":"Bragg Peak","text":"In\u00a0[48]: Copied! <pre>from protonic import bethebloch, elements, projectiles, compounds\nimport matplotlib.pyplot as plt\n\n# delta x\ndelta_x = max_delta_x = 0.01 # cm\nmin_delta_x = 1e-7\n\n# Initial values\nxi = xcm = 0 # initial depth\nE = 200 # initial energy of proton in MeV\n\n# vector to store values\nvecE = []\nvecX = []\nvecdX = []\n\n# materials and projectiles to use \nprojectile = projectiles.get(\"proton\")\nmaterial = compounds.get(\"H2O\") # water\n\n# Numerical integration\nwhile True:\n    xi += delta_x # move to next depth\n    xcm = xi / material.rho\n\n    dEdx = bethebloch(E, material, projectile) \n    if dEdx &lt; 0: \n       break\n    elif len(vecE) &gt; 0: \n        delta_x = max(min(0.01, delta_x / (dEdx - vecE[-1])), 1e-7) # calculate new delta x\n        \n    # update energy\n    E = E - dEdx * delta_x \n\n    # add values to vectors\n    vecE.append(dEdx)\n    vecX.append(xcm)\n    vecdX.append(delta_x)\n\n# plotting\nfig, ax = plt.subplots(1, figsize=(10,5))\nax.plot(vecX, vecE, '-k')\nax.set_xlim(25.65,25.655)\nax.set_xlabel(\"Depth [cm]\")\nax.set_ylabel(\"Radiation dose [MeV / cm]\")\nax.set_title(\"Bragg peak of a proton beam in water\")\n</pre> from protonic import bethebloch, elements, projectiles, compounds import matplotlib.pyplot as plt  # delta x delta_x = max_delta_x = 0.01 # cm min_delta_x = 1e-7  # Initial values xi = xcm = 0 # initial depth E = 200 # initial energy of proton in MeV  # vector to store values vecE = [] vecX = [] vecdX = []  # materials and projectiles to use  projectile = projectiles.get(\"proton\") material = compounds.get(\"H2O\") # water  # Numerical integration while True:     xi += delta_x # move to next depth     xcm = xi / material.rho      dEdx = bethebloch(E, material, projectile)      if dEdx &lt; 0:         break     elif len(vecE) &gt; 0:          delta_x = max(min(0.01, delta_x / (dEdx - vecE[-1])), 1e-7) # calculate new delta x              # update energy     E = E - dEdx * delta_x       # add values to vectors     vecE.append(dEdx)     vecX.append(xcm)     vecdX.append(delta_x)  # plotting fig, ax = plt.subplots(1, figsize=(10,5)) ax.plot(vecX, vecE, '-k') ax.set_xlim(25.65,25.655) ax.set_xlabel(\"Depth [cm]\") ax.set_ylabel(\"Radiation dose [MeV / cm]\") ax.set_title(\"Bragg peak of a proton beam in water\") <pre>/var/folders/cs/wh423ttd7gn4q0847pq48zrc0000gn/T/ipykernel_68964/2849494507.py:30: RuntimeWarning: divide by zero encountered in scalar divide\n  delta_x = max(min(0.01, delta_x / (dEdx - vecE[-1])), 1e-7) # calculate new delta x\n</pre> Out[48]: <pre>Text(0.5, 1.0, 'Bragg peak of a proton beam in water')</pre>"},{"location":"bragg_peak/#bragg-peak","title":"Bragg peak\u00b6","text":"<p>The previous figures show the energy loss of protons. In formula, this is described as:</p> <p>$$ -\\frac{dE}{dx} = f(E) $$</p> <p>Here, $f(E)$ is described using the Bethe-Bloch approximation. The next step is to plot in the tissue the charge is deposited. This can be done by integrating f(E) over x. We will do this numerically:</p> <p>$$ \\Delta E = f(E)\\Delta x $$</p> <p>So:</p> <p>$$ E_{i+1} = E_{i} - \\Delta E $$</p> <p>It turns out that for protons, the area over which most of the dose is deposited is very small. To speed up computations, we therefore introduces a variable $\\Delta x$ that gets smaller as $\\frac{dE}{dx}$ gets smaller.</p> <p>A characteristic of charged particles (like protons) is that they deposit most of their energy towards the end of their path in a medium, resulting in a peak in the dose distribution known as the Bragg Peak. This phenomenon has revolutionised cancer treatment by offering an approach that maximises damage to cancerous cells while sparing healthy tissue, a goal that is the cornerstone of effective radiation therapy.</p> <p>Charged particles, such as protons and heavy ions, lose energy when passing through material primarily through ionization. The Bethe-Bloch equation describes that energy loss. The Bragg Curve is a graph of the energy loss rate, or Linear Energy Transfer (LET) as a function of the distance through a stopping medium. The energy loss is characterized primarily by the square of the nuclear charge, Z, and the inverse square of the projectile velocity, \u03b2. This gives the Bragg Curve its familiar shape, peaking at very low energies, just before the projectile stops. It is this Bragg Peak that makes ion therapy advantageous over X-ray treatment for cancer. The Bragg Curve falls with increasing energy until a minimum is reached near a velocity of \u03b2 = 0.9, about 2.2 GeV for protons. LET increases slowly, rising logarithmically for energies above the minimum. [https://www.bnl.gov/nsrl/userguide/bragg-curves-and-peaks.php]</p>"},{"location":"constants/","title":"Constants","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>Na = 6.022e23 # Avogadro's number [mol**-1]\nre = 2.8179e-13 # classical electron radius [cm]\nmec2 = 0.511 # MeV\nc = 299792458 # speed of light [ms^-1]\ne = -1  # elementary electron charge in e units [-1.602176634e-19 C]\ne0 = 55.26349406e-9 # e2/(MeV m)\n</pre> Na = 6.022e23 # Avogadro's number [mol**-1] re = 2.8179e-13 # classical electron radius [cm] mec2 = 0.511 # MeV c = 299792458 # speed of light [ms^-1] e = -1  # elementary electron charge in e units [-1.602176634e-19 C] e0 = 55.26349406e-9 # e2/(MeV m)"},{"location":"protonic/","title":"Protonic","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np \nfrom collections import namedtuple\nimport constants as const\n</pre> import numpy as np  from collections import namedtuple import constants as const In\u00a0[\u00a0]: Copied! <pre>Material = namedtuple('Material', ['Z', 'A', 'I', 'rho'])\nCompound = namedtuple('Compound', ['elements', 'weights', 'rho'])\nelements = {\n    \"H\": Material(Z=1, A=1, I=19.2e-6, rho = 8.37480E-05), \n    \"HE\": Material(Z=2, A=4, I=41.8e-6, rho=1.66322E-04),\n    \"Fe\": Material(Z=26, A = 55.845, I = 286e-6, rho=7.874),\n    \"O\": Material(Z=8, A=15.999, I=95e-6, rho= 1.33151E-03),\n    \"air\": Material(Z=7, A=28, I=85e-6, rho=1.225E-03), # move to compounds https://physics.nist.gov/cgi-bin/Star/compos.pl?refer=ap&amp;matno=104\n}\n</pre> Material = namedtuple('Material', ['Z', 'A', 'I', 'rho']) Compound = namedtuple('Compound', ['elements', 'weights', 'rho']) elements = {     \"H\": Material(Z=1, A=1, I=19.2e-6, rho = 8.37480E-05),      \"HE\": Material(Z=2, A=4, I=41.8e-6, rho=1.66322E-04),     \"Fe\": Material(Z=26, A = 55.845, I = 286e-6, rho=7.874),     \"O\": Material(Z=8, A=15.999, I=95e-6, rho= 1.33151E-03),     \"air\": Material(Z=7, A=28, I=85e-6, rho=1.225E-03), # move to compounds https://physics.nist.gov/cgi-bin/Star/compos.pl?refer=ap&amp;matno=104 } In\u00a0[\u00a0]: Copied! <pre>compounds = {\n    \"H2O\": Compound(elements=[elements.get(\"H\"), elements.get(\"O\")], weights=[0.111894, 0.888106], rho=1.000)\n    }\n</pre> compounds = {     \"H2O\": Compound(elements=[elements.get(\"H\"), elements.get(\"O\")], weights=[0.111894, 0.888106], rho=1.000)     } In\u00a0[\u00a0]: Copied! <pre>Projectile = namedtuple('Projectile', ['E0',            # rest mass in MeV\n                                       'm0',            # rest mass in kg\n                                       'z'              # particle charge in e\n                                       ])\n</pre> Projectile = namedtuple('Projectile', ['E0',            # rest mass in MeV                                        'm0',            # rest mass in kg                                        'z'              # particle charge in e                                        ]) In\u00a0[\u00a0]: Copied! <pre>projectiles = {\n    \"proton\": Projectile(E0=938.27208943, m0=1.67262e-27, z=1),\n    \"alpha\": Projectile(E0=3727.379, m0=6.644656e-27, z=2),\n}\n</pre> projectiles = {     \"proton\": Projectile(E0=938.27208943, m0=1.67262e-27, z=1),     \"alpha\": Projectile(E0=3727.379, m0=6.644656e-27, z=2), } In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>def PSTAR(material=\"H\"):\n    \"\"\"\n    Read PSTAR data for a given material.\n    The data is stored in a file named \"pstar{material}.dat\" in the \"../data/\" directory.\n    The file format is as follows:\n    - The first 8 lines are header information.\n    - The data starts from the 9th line onwards.\n    - The data is space-separated.\n    - The first column is the energy in MeV.\n    - The second column is the stopping power in MeV cm^2/g.\n    - The third column is the range in g/cm^2.\n    \"\"\"\n    with open(f\"../data/pstar{material}.dat\", \"r\") as f:\n        lines = [line.strip() for line in f]\n        data = np.loadtxt(lines, delimiter=' ', skiprows=8)\n    return data\n</pre> def PSTAR(material=\"H\"):     \"\"\"     Read PSTAR data for a given material.     The data is stored in a file named \"pstar{material}.dat\" in the \"../data/\" directory.     The file format is as follows:     - The first 8 lines are header information.     - The data starts from the 9th line onwards.     - The data is space-separated.     - The first column is the energy in MeV.     - The second column is the stopping power in MeV cm^2/g.     - The third column is the range in g/cm^2.     \"\"\"     with open(f\"../data/pstar{material}.dat\", \"r\") as f:         lines = [line.strip() for line in f]         data = np.loadtxt(lines, delimiter=' ', skiprows=8)     return data In\u00a0[\u00a0]: Copied! <pre>def bethebloch(Ek, material:Material|Compound, projectile:Projectile) -&gt; float:\n    \"\"\"\n    Calculate the Bethe-Bloch formula for a given energy, material, and projectile.\n    Ek: Kinetic energy in MeV\n    material: Material object or list of Material objects\n    projectile: Projectile object\n    \"\"\"\n\n    beta = lambda Ek:  (1-(Ek/projectile.E0 + 1)**-2)**0.5\n    K = 4*np.pi*const.Na*const.re**2*const.mec2  # MeV cm2 / g\n    logterm = lambda material: np.log(2*const.mec2*beta(Ek)**2/(material.I*(1-beta(Ek)**2)))\n    bethe = lambda Ek, material, projectile: K * projectile.z**2 * material.Z / material.A * 1 / beta(Ek)**2 * (logterm(material) - beta(Ek)**2)\n    bethe_compound = lambda x, compound, projectile: np.sum([weight*bethe(x, element, projectile) for element, weight in zip(compound.elements, compound.weights)], axis=0) \n    \n    if isinstance(material, Material):\n        return bethe(Ek, material, projectile)\n    elif isinstance(material, Compound):\n        return bethe_compound(Ek, material, projectile)\n</pre> def bethebloch(Ek, material:Material|Compound, projectile:Projectile) -&gt; float:     \"\"\"     Calculate the Bethe-Bloch formula for a given energy, material, and projectile.     Ek: Kinetic energy in MeV     material: Material object or list of Material objects     projectile: Projectile object     \"\"\"      beta = lambda Ek:  (1-(Ek/projectile.E0 + 1)**-2)**0.5     K = 4*np.pi*const.Na*const.re**2*const.mec2  # MeV cm2 / g     logterm = lambda material: np.log(2*const.mec2*beta(Ek)**2/(material.I*(1-beta(Ek)**2)))     bethe = lambda Ek, material, projectile: K * projectile.z**2 * material.Z / material.A * 1 / beta(Ek)**2 * (logterm(material) - beta(Ek)**2)     bethe_compound = lambda x, compound, projectile: np.sum([weight*bethe(x, element, projectile) for element, weight in zip(compound.elements, compound.weights)], axis=0)           if isinstance(material, Material):         return bethe(Ek, material, projectile)     elif isinstance(material, Compound):         return bethe_compound(Ek, material, projectile) In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    # Example usage\n    material = elements.get(\"H\")\n    projectile = projectiles.get(\"proton\")\n    Ek = 1.0  # Kinetic energy in MeV\n    print(bethebloch(Ek, material, projectile))\n    \n    # Example usage for compound\n    compound = compounds.get(\"H2O\")\n\n    print(bethebloch(Ek, compound, projectile))\n    # Example usage for PSTAR\n    # material = \"H\"\n    # data = PSTAR(material)\n    # print(data)\n</pre> if __name__ == \"__main__\":     # Example usage     material = elements.get(\"H\")     projectile = projectiles.get(\"proton\")     Ek = 1.0  # Kinetic energy in MeV     print(bethebloch(Ek, material, projectile))          # Example usage for compound     compound = compounds.get(\"H2O\")      print(bethebloch(Ek, compound, projectile))     # Example usage for PSTAR     # material = \"H\"     # data = PSTAR(material)     # print(data)"},{"location":"references/","title":"References","text":""},{"location":"references/#references","title":"References","text":"<p>Newhauser &amp; Zhang (2015) The physics of proton therapy. Phys Med Biol. 2015 Mar 24;60(8):R155\u2013R209. doi: 10.1088/0031-9155/60/8/R155</p> <p>Palmans, PTRAN, a Monte Carlo code for transport simulation of 50 to 250 MeV protons, http://resource.npl.co.uk/docs/science_technology/ionising%20radiation/clubs_groups/monte_carlo/2004/workshop/ptran_notes.pdf</p> <p>Berger (1993) Penetration of Proton Beams Through Water I. Depth-dose Distribution, Spectra and LET Distribution https://archive.org/details/penetrationofpro5226berg/page/n2/mode/1up</p> <p>Introduction to elementary particle physics: https://www.phys.ufl.edu/~korytov/tmp4/lectures/note_A10_interaction_of_particles_with_matter.pdf</p> <p>Salvat, F. (2022), Bethe stopping-power formula and its corrections, PHYSICAL REVIEW A 106, 032809, DOI: 10.1103/PhysRevA.106.032809</p> <p>Salvat, F., Barjuan, L., Andreo, P. (2022), Inelastic collisions of fast charged particles with atoms: Bethe asymptotic formulas and shell corrections, Phys. Rev. A 105, 042813, DOI: https://doi.org/10.1103/PhysRevA.105.042813</p> <p>Sengbush et al. Maximum proton kinetic energy and patient-generated neutron fluence considerations in proton beam arc delivery radiation therapy, Med Phys. 2009 Jan 8;36(2):364\u2013372. doi: 10.1118/1.3049787</p>"}]}